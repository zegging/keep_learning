# 一共有N个位置，N>1                             12345
# 现在在S位置，希望在K步后到达E位置            1(S=2)3(E=4)5
# 每次向左或者向右走，求一共有多少种不同的走法

'''
动态规划入门：暴力递归 --> 记忆化搜索 --> 动态规划
'''

'''
暴力递归
'''

def f1(N,E,cur,rest):
    '''
    :param N: 位置总数
    :param E: 希望到达的位置
    :param cur: 现在所处的位置
    :rest: 剩余移动的步数
    :return: 在cur位置移动rest步可以到达E位置的不同路线的数量
    '''
    # 递归终结的边界条件，即没有剩余的移动步数了
    if rest == 0:
        return 1 if cur==E else 0

    # 没有在 rest == 0 返回，即 rest >= 1
    # 如果现在在的位置是1位置，则下一步只能向右走，即到达2位置，到达2位置的时候还能移动的步数是 rest-1
    if cur == 1:
        return f1(N, E, 2, rest-1)

    # 没有在 rest == 0 返回，即 rest >= 1
    # 如果现在在的位置是5位置，则下一步只能向左走，即到达4位置，到达4位置的时候还能移动的步数是 rest-1
    if cur == N:
        return f1(N, E, 4, rest-1)

    # 没有在1、5位置，则接下来可能向右也可能向左
    # 所以目前位置能够到达E位置的路线的数量是 cur = cur+1 和 cur-1 且 rest = rest-1 的可能性的和
    return f1(N, E , cur+1, rest-1) + f1(N, E, cur-1, rest-1)

count = f1(5,4,2,4)
print(count)

print('-------------------------------------------------------------------')

'''
记忆化搜索，等于是构建了一个缓存，保存了已经在 (cur, rest) 情况计算过的路线数量
所以在递归函数中需要加入新的参数（缓存过的信息）和边界条件（这种情况已经在缓存中）

在f1中的递归过程我们可以发现其实只有两个参数标识了这种情况下的状态信息（可能的路线数），
即 count 是被 (cur,rest)唯一确定的，count = f(cur, rest)
提示我们可以用一个二维数组（矩阵）来存储已经计算过的信息

时间复杂度O(N*K)，空间复杂度O(N*K)
'''

def init_dp(N, K):
    '''
    :param N: 一共有N个位置
    :param K: 一共需要走K步
    :return: 记录缓存的二维数组
    '''
    # 需要保存的剩余步数的信息为0，1，2，3，4
    # 需要保存的位置的信息为1，2，3，4，5
    # 我们在dp中用外部列表保存每种剩余步数下的信息，用内部列表保存确定剩余步数时每个位置能够到达E位置的路线数。
    # 即 dp[i] = [-1,-1,-1,-1,-1,-1] 中保存的是剩余i步且当前位置在0，1，2，3，4，5时能够到达E位置的路线数，初始化为-1
    # 在这里我们多保存一列0位置的无效信息，可以将index和位置直接对应，便于理解
    
    '''
    dp = [[-1]*(N+1)]*(K+1)
    return dp
    注意，这样的生成是错误的，因为 dp[i] i=0,1,2,3,4 其实都是同一个可变对象 [-1]*(N+1) 
    赋值的时候会产生错误，比如 dp[0][4] = 1，dp整体就会变成：
    [[-1, -1, -1, -1, 1, -1], 
     [-1, -1, -1, -1, 1, -1], 
     [-1, -1, -1, -1, 1, -1], 
     [-1, -1, -1, -1, 1, -1],
     [-1, -1, -1, -1, 1, -1]]
     我们需要挨个赋值，使用生成器
    '''
    dp = [[-1 for _ in range(N+1)] for _ in range(K+1)]
    return dp


dp = init_dp(5,4)
print(dp)

def f2(N,E,cur,rest,dp):
    '''
    :param N: 位置总数
    :param E: 希望到达的位置
    :param cur: 现在所处的位置
    :rest: 剩余移动的步数
    :param dp: 缓存信息
    :return: 在cur位置移动rest步可以到达E位置的不同路线的数量
    '''

    # 如果这个二维数组这个位置上的数不是-1，就意味着这种情况已经计算过了，可以直接返回信息
    if dp[rest][cur] != -1:
        return dp[rest][cur]

    # 如果这个二维数组这个位置上的数是-1，就需要计算路线数，并将结果保存到dp中
    if rest == 0:
        dp[rest][cur] = 1 if cur==E else 0

    elif cur == 1:
        dp[rest][cur] = f2(N, E, 2, rest-1, dp)

    elif cur == N:
        dp[rest][cur] = f2(N, E, N-1, rest-1, dp)

    else:
        dp[rest][cur] = f2(N, E , cur+1, rest-1, dp) + f2(N, E, cur-1, rest-1, dp)

    print(dp)
    return dp[rest][cur]

count = f2(5,4,2,4,dp=dp)
print(count)

print('-------------------------------------------------------------------')

'''
动态规划，其实就是找到dp这个二维表中每个位置的数对其他位置的数的依赖关系
所以我们从递归边界开始反推这个过程

     0   1   2   3   4   5
0 [[-1, -1, -1, -1, -1, -1], 
1  [-1, -1, -1, -1, -1, -1], 
2  [-1, -1, -1, -1, -1, -1], 
3  [-1, -1, -1, -1, -1, -1],
4  [-1, -1, -1, -1, -1, -1]]

第一行的返回是显然的

     0   1   2   3   4   5
0 [[-1,  0,  0,  0,  1,  0], 
1  [-1, -1, -1, -1, -1, -1], 
2  [-1, -1, -1, -1, -1, -1], 
3  [-1, -1, -1, -1, -1, -1],
4  [-1, -1, -1, -1, -1, -1]]

从最初的递归函数中我们可以知道当 cur = 1 和 cur = 5 时 dp[rest][cur] 依赖（等于） dp[rest-1][2] 和 dp[rest-1][4]；当 cur = 2,3,4 时 dp[rest][cur] 依赖于（等于它们的和） dp[rest-1][cur+1] 和dp[rest-1][cur-1]

由此我们可以一行一行直接填数

rest = 1
     0   1   2   3   4   5
0 [[-1,  0,  0,  0,  1,  0], 
1  [-1,  0,  0,  1,  0,  1], 
2  [-1, -1, -1, -1, -1, -1], 
3  [-1, -1, -1, -1, -1, -1],
4  [-1, -1, -1, -1, -1, -1]]

rest = 2
     0   1   2   3   4   5
0 [[-1,  0,  0,  0,  1,  0], 
1  [-1,  0,  0,  1,  0,  1], 
2  [-1,  0,  1,  0,  2,  0], 
3  [-1, -1, -1, -1, -1, -1],
4  [-1, -1, -1, -1, -1, -1]]

rest = 3
     0   1   2   3   4   5
0 [[-1,  0,  0,  0,  1,  0], 
1  [-1,  0,  0,  1,  0,  1], 
2  [-1,  0,  1,  0,  2,  0], 
3  [-1,  1,  0,  3,  0,  2],
4  [-1, -1, -1, -1, -1, -1]]

rest = 2
     0   1   2   3   4   5
0 [[-1,  0,  0,  0,  1,  0], 
1  [-1,  0,  0,  1,  0,  1], 
2  [-1,  0,  1,  0,  2,  0], 
3  [-1,  1,  0,  3,  0,  2],
4  [-1,  0,  4,  0,  5,  0]]

返回 dp[4][2] = 4

在这种情况下，就意味着我们只需要做第一层 rest = 0 的计算，之后的每一层 rest += 1 都依赖于上一层的结果
时间复杂度O(N*K)，空间复杂度O(N*K)
'''

def f3(N,E,K,S):
    '''
    :param N: 位置总数
    :param E: 希望到达的位置
    :param K: 一共走的步数
    :param S: 起始位置
    '''
    # 生成二维数组，这下我们直接将每个位置填为0，因为不需要判断是否计算过（上一层的肯定计算过了）
    dp = [[0 for _ in range(N+1)] for _ in range(K+1)]

    # 初始化第0行的位置信息
    dp[0][E] = 1

    line = 1
    # 迭代计算接下来的每一行
    while line <= K:
        # 迭代计算line行中的row列的数
        row = 1
        while row <= N:
            if row == 1:
                dp[line][row] = dp[line-1][2]
            elif row == 5:
                dp[line][row] = dp[line-1][4]
            else:
                dp[line][row] = dp[line-1][row+1] + dp[line-1][row-1]
            row += 1
        line += 1

    return dp[K][S]

count = f3(5, 4, 4, 2)
print(count)
