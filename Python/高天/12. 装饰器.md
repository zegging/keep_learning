# 装饰器

> 装饰器的本质就是它的等价形式

## function object

python中的所有对象都是object，函数只是python中一个普通的object而已。我们可以看一下函数是怎么被编译成字节码的：

```python
def double(x):
    return x * 2

print(double(2))
```

以上代码被编译器编译成如下的字节码：

```python
# PART 1
  1           0 LOAD_CONST               0 (<code object double at 0x000001D52CD4EEF0, file "<dis>", line 1>)
              2 LOAD_CONST               1 ('double')
              4 MAKE_FUNCTION            0
              6 STORE_NAME               0 (double)

  4           8 LOAD_NAME                1 (print)
             10 LOAD_NAME                0 (double)
             12 LOAD_CONST               2 (2)
             14 CALL_FUNCTION            1
             16 CALL_FUNCTION            1
             18 POP_TOP
             20 LOAD_CONST               3 (None)
             22 RETURN_VALUE

Disassembly of <code object double at 0x000001D52CD4EEF0, file "<dis>", line 1>:
  2           0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (2)
              4 BINARY_MULTIPLY
              6 RETURN_VALUE
```

在PART 1中先将这个代码块的code object和字符串double使用MAKE_FUNCTION返回一个function object，然后将这个function object赋值给变量double。

所以函数对象显然也可以和其他对象一样作为参数传递进其他函数中。

```python
def double(x):
    return x * 2

def triple(x):
    return x * 3

def calc_number(x, func):
    return func(x)

res = calc_number(2, double)
print(res)
res = calc_number(2, triple)
print(res)

# 4
# 6
```

函数也可以作为返回值被return

```python
def get_multiple_of_number(n):

    def multiple(x):
        return n * x

    return multiple

double = get_multiple_of_number(2)
triple = get_multiple_of_number(3)

print(double(5))
print(triple(5))

# 10
# 15
```

## 装饰器decorator

### 装饰器的原理

装饰器本质上其实就是一个函数，这个函数接收一个function object然后做一些操作之后返回一个function（也有可能不返回，取决于这里的业务逻辑是什么）。

```python
def dec(f):
    pass

@dec
def double(x):
    return x * 2
```

以上代码被编译成字节码后的结果是这样的：

```python
  1           0 LOAD_CONST               0 (<code object dec at 0x0000027B1A71EE40, file "<dis>", line 1>)
              2 LOAD_CONST               1 ('dec')
              4 MAKE_FUNCTION            0
              6 STORE_NAME               0 (dec)
# PART：
  4           8 LOAD_NAME                0 (dec)

  5          10 LOAD_CONST               2 (<code object double at 0x0000027B1A71F050, file "<dis>", line 4>)
             12 LOAD_CONST               3 ('double')
             14 MAKE_FUNCTION            0
             16 CALL_FUNCTION            1
             18 STORE_NAME               1 (double)
             20 LOAD_CONST               4 (None)
             22 RETURN_VALUE

Disassembly of <code object dec at 0x0000027B1A71EE40, file "<dis>", line 1>:
  2           0 LOAD_CONST               0 (None)
              2 RETURN_VALUE

Disassembly of <code object double at 0x0000027B1A71F050, file "<dis>", line 4>:
  6           0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (2)
              4 BINARY_MULTIPLY
              6 RETURN_VALUE
```

我们使用一种更容易理解的方式创建装饰器：

```python
def dec(f):
    pass

def double(x):
    return x * 2
    
double = dec(double)
```

编译成字节码结果如下：

```python
  1           0 LOAD_CONST               0 (<code object dec at 0x00000239B78DEE40, file "<dis>", line 1>)
              2 LOAD_CONST               1 ('dec')
              4 MAKE_FUNCTION            0
              6 STORE_NAME               0 (dec)

  4           8 LOAD_CONST               2 (<code object double at 0x00000239B78DF050, file "<dis>", line 4>)
             10 LOAD_CONST               3 ('double')
             12 MAKE_FUNCTION            0
             14 STORE_NAME               1 (double)
# PART：
  7          16 LOAD_NAME                0 (dec)
             18 LOAD_NAME                1 (double)
             20 CALL_FUNCTION            1
             22 STORE_NAME               1 (double)
             24 LOAD_CONST               4 (None)
             26 RETURN_VALUE

Disassembly of <code object dec at 0x00000239B78DEE40, file "<dis>", line 1>:
  2           0 LOAD_CONST               0 (None)
              2 RETURN_VALUE

Disassembly of <code object double at 0x00000239B78DF050, file "<dis>", line 4>:
  5           0 LOAD_FAST                0 (x)
              2 LOAD_CONST               1 (2)
              4 BINARY_MULTIPLY
              6 RETURN_VALUE
```

我们可以看到装饰器起作用的部分（PART）它们的字节码是一样的。

### 一个简单的装饰器

```python
import time

def timeit(f):

    def wrapper(*args, **kwargs):
        start = time.time()
        result = f(*args, **kwargs)
        end = time.time()
        print(f.__name__, end - start)
        return result

    return wrapper

@timeit
def fun(x):
    time.sleep(x)


fun(1)

# fun 1.0147085189819336
```

这样我们就做了一个可以计算函数运行时间的装饰器，加入了装饰器之后调用`fun(1)`其实等价于如下代码：

```python
import time

def timeit(f):

    def wrapper(*args, **kwargs):
        start = time.time()
        result = f(*args, **kwargs)
        end = time.time()
        print(f.__name__, end - start)
        return result

    return wrapper


def fun(x):
    time.sleep(x)


timeit(fun)(1)

# fun 1.0114350318908691
```

### 带参数的装饰器

装饰器本身作为一个函数是可以接收不止一个参数的，所以利用这种特性我们可以对装饰器进行传参。

```python
import time

def timeit(iteration):

    def inner(f):

        def wrapper(*args, **kwargs):
            start = time.time()
            for _ in range(iteration):
                f(*args, **kwargs)
            end = time.time()
            print(f.__name__, end - start)

        return wrapper

    return inner

@timeit(100000)
def double(x):
    return x * 2

double(2)

# double 0.007983922958374023
```

这两种写法是等价的，它们都是计算了运行100000次`double(2)`所花费的时间。

```python
import time

def timeit(iteration):

    def inner(f):

        def wrapper(*args, **kwargs):
            start = time.time()
            for _ in range(iteration):
                f(*args, **kwargs)
            end = time.time()
            print(f.__name__, end - start)

        return wrapper

    return inner

def double(x):
    return x * 2

inner = timeit(100000)
double = inner(double)
double(2)

# double 0.007983922958374023
```

## 类装饰器 class decorator

这个名称是有歧义的，可以理解为两个不同的含义：

1. 可以装饰类的装饰器，类是装饰器装饰的对象
2. 可以当作装饰器使用的类，装饰器本身是一个类

### 类作为装饰器

实际上装饰器装饰的对象和装饰器本事都可以是类也可以是函数，所以我们需要了解的是这背后的核心机制以及原理。

```python
import time

class Timer:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        start = time.time()
        res = self.func(*args, **kwargs)
        print(time.time() - start)
        return res


@Timer
def add(a, b):
    return a + b

print(add(1, 2))

# 0.0
# 3
# <class '__main__.Timer'>
```

`__call__`方法的作用是将类的实例可以当作一个函数去使用。可以看到在加上了装饰器`@Timer`后函数`add()`的类变为了Timer，这是因为装饰器等价于：

```python
add = Timer(add)
```

然后我们像使用一个函数一样使用这个Timer object add的时候就会调用Timer类的`__call__`方法。

我们也可以给这个作为装饰器使用的类进行传参

```python
import time

class Timer:
    def __init__(self, prefix):
        self.prefix = prefix

    def __call__(self, func):
        def wrapper(*args, **kwargs):
            start = time.time()
            result = func(*args, **kwargs)
            end = time.time()
            print(self.prefix, end - start)
            return result
        return wrapper

@Timer(prefix='spend_time:')
def add(a, b):
    return a + b

print(add(1, 2))
print(add.__class__)

# spend_time: 0.0
# 3
# <class 'function'>
```

实际上这就等价于

```python
add = Timer('spend_time:')(add)
```

### 目标是类的装饰器

```python
def add_str(cls):
    def __str__(self):
        return str(self.__dict__)

    cls.__str__ = __str__
    return cls

@add_str
class MyObject:
    def __init__(self, a, b):
        self.a = a
        self.b = b


o = MyObject(1, 2)
print(MyObject.__class__)
print(o.__class__)
print(o)

# <class 'type'>
# <class '__main__.MyObject'>
# {'a': 1, 'b': 2}
```

很显然我们通过这个装饰器的等价形式非常好理解

```python
MyObject = add_str(MyObject)
```

这里我们将MyObject作为参数传入了add_str()这个函数中，然后将这个类的`__str__`方法进行了重写，然后返回了这个类。所以在`print(o)`的时候就会打印`o.__dict__`。