# 锁的功能

## 读锁

共享锁，组织其他用户更新数据，但允许读取数据。在一段时间内保证数据的一致性

## 写锁

排他锁，阻止其他用户读取和更新数据。不希望其他用户对数据进行干扰。

# 锁的粒度

## 全局锁

进行一些需要确保整个数据库一致性的操作，比如全库备份、全库导出等。

#### 语句

`FLUSH TABLES WITH READ LOCK` 用于在执行备份或者执行一些需要保持数据库一致性的操作时，暂停其他会话对表的写入。

当执行 `FLUSH TABLES WITH READ LOCK` 语句后，当前会话（连接）将获取一个全局的读锁，确保在该会话释放锁之前，其他会话无法对表进行写操作。这样可以确保备份数据的一致性，因为在备份期间没有其他会话对表进行更改。

**请注意，`FLUSH TABLES WITH READ LOCK` 只会对当前会话有效，并不会阻止其他会话对已经存在的连接进行写操作，只会阻止新的写入操作**，要解除锁定，可以使用 `UNLOCK TABLES` 命令。已经存在的连接仍然可以进行写操作，以便不中断其他正在进行的任务。这种方式能够实现数据库备份的同时不影响正常的数据库操作。

需要注意的是，在使用 `FLUSH TABLES WITH READ LOCK` 后，虽然其他会话无法对表进行写操作，但对表的读操作仍然是允许的。

## 表锁

表级锁可以通过使用以下语句来实现：

`LOCK TABLES table_name [AS alias] {READ | WRITE}`: 获取表级锁，用于读取或写入指定的表。需要注意的是，在使用 `LOCK TABLES` 之前，需要先关闭自动提交事务的功能。

MyISAM没有事务，所以使用的是表锁。InnoDB默认使用行锁。

#### 使用场景

1. 读密集型：应为不阻塞读操作
2. 写不频繁
3. 数据量不大
4. 全表更新或删除

## 行锁

# 锁的模式分类

# 锁的属性分类

# 锁的状态分类

# 锁的算法分类



